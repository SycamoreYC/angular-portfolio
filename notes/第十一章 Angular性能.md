# 第十一章 开发健壮的Angular JS应用

## 11.1 理解Angular Js的内部运作机制

### Angular JS不是基于字符串的模版引擎

#### 响应DOM事件更新模型

Angular JS通过不同指令注册的DOM事件监视器来将DOM树的变化传播给模型。事件监视器中的代码通过修改$scope暴露的变量来更新模型。

#### 将模型变化传播给DOM

#### 同步DOM和模型变化

要添加$watch后才可以将模型的每一次变化都展示出来。

```javascript
$watch(watchExpression, modelChangeCallback);
```

其中，watchExpression可以是一个函数，也可以是一个Angular JS 表达式，用于指定要监控的模型值。

modelCallback是一个回调函数，会在每次watchExpression的值发生变化时被调用。

modelCallback本身可以接受两个参数，分别是watchExpression变化前后的值。

#### Scope.$apply

Angular JS在何时以何种形式监视模型的变化？？？

首先，我们需要明确，引发模型变化的情况是有限的。这些情况包括：

- DOM事件
- XHR响应出发回调
- 浏览器的地址变化
- 计时器触发回调

如果上面的情况没有发生，那么即使监控模型的变化也是没有意义的。

所以，Angular JS需要在被明确告知的有事情发生的时候再启动其模型监控机制。为了达到这个效果，Angular JS需要在scope上执行$apply方法。

#### 深入$digest循环

在Angular JS中，把检测模型变化的过程称为$digest循环。

$digest是Scope实例上的一个重要方法，被作为$apply中的重要一步来调用，它会检测注册在所有作用域上的所有监视对象。

$digest循环存在的意义：

- 判定模型的哪些部分发生了变化，以及DOM中的哪些属性应该被更新。
- 减少不必要的重绘以提高性能。Angular JS会将DOM重绘尽可能推迟到最后一刻。

要实现以上效果：

​	首先要知道，Web浏览器只有一个UI线程。准确的说是只要一个线程用于渲染DOM元素、监视DOM事件，以及执行JS代码。浏览器不停的在JS执行环境和DOM渲染环境之间切换。

​	Angular JS确保在将执行权交还给DOM渲染环境之前，所有的模型值都已完成运算且已“稳定”。这种方式保证了UI一次性完成重绘，而且不会为了响应某个单独的模型变化而不停的重绘。

##### 1. 解剖$watch 

Angular JS 使用脏检查机制来判定某个模型值是否真正发生了变化。脏检查的工作机制是将之前保存的模型值和能导致模型变化的事件发生后计算的心模型值做对比。

```javascript
$watch(watchExpression, modelChangeCallback);
```

当作用域添加了$watcha以后，Angular JS会运算watchExpression表达式，然后在内部将运算所得的值存储起来，紧接着进入$digest循环，watchExpression会被再次运算，运算所得的新值会和之前保存的值进行对比。modelChangeCallback只会在新值与旧值不同时才会执行。这个新值也会被保存起来以备下一次对比使用，然后一直这样下去。

我们还要知道，任何指令（内置，第三方）都可以设置自己的监视器，任何的插值表达式也都会在作用域上注册一个新的监视。

##### 2. 模型的稳定性

如果模型上的人和一个监视器都检测不到任何变化，Angular JS就认为该模型是稳定的。只要有一个监视器的一个变化，就会让整个$digest变“脏”，让Angular JS进入又一轮循环。

> 任何一个$digest循环至少都会被运行一次，一般情况下会运行两次。每一个被监视的表达式在每个$digest循环中都会被运算两次。

##### 3. 不稳定的模型

Angualr JS 默认最多会执行10次循环，之后就会声明该模型是不稳定的，然后中断$digest循环。

###### 1. $digest循环和作用域的层级

每次$digest循环都会从$rootScope开始，重新计算所有作用域上的所有监视表达式。

从$rootScope开始是因为子作用域上的变化有可能会影响父作用域上的变量。

## 11.2 性能优化

要用数据说话，要解决可测量的问题。

## 11.3 Angular JS 应用的性能优化

### 优化CPU使用率

#### 加速$digest循环

##### 1. 保持监视器简单快速

首先，尽量减少监视表达式中的耗时计算。

​	通常在模版中使用简单的表达式。

​	不要在运行代码中出现记录日志的语句console.log()。

​	尽量避免使用过滤器。

​	避免在监视表达式中访问DOM。

##### 2. 限制监视器的数量

删除不必要的监视。

> 每当我们要向模版中追加一个插值表达式时，试着评估它是否能收益于双向数据绑定。

用心琢磨UI界面。

不监视隐藏元素。

> 使用ng-switch、ng-if之类的，从DOM树上删除需要隐藏的元素。

在受影响作用域明确的情况下使用Scope.$digest替代Scope.$apply。

>  scope.$digest会在指定的作用域子集上运行$digest循环。

删除不用的监视器。

#### 尽可能少进入$digest循环

Angular JS指令和服务一般监听4种事件，以便触发调用scope.$apply()方法。

- 导航事件
- 网络事件：所有对$http服务的调用在得到响应后都会触发$digest循环。
- DOM事件
- JS计时器：计时器完成后，$time服务会触发一次$digest循环。

一些可以减少进入$digest循环频次的技巧：

- 减少网络事件调用的次数
- 特别注意计时器的使用

> $timeout服务的第三个参数，用于设定在计时服务中是否调用scope.$apply

- 注册大量特定DOM事件处理函数后，触发极大数量的$digest循环时

> 考虑自己编写自定义指令，根据DOM事件和模型变化直接进行DOM修改。

### 优化内存占用

#### 尽可能避免深度监视

> 深度监视在性能上有双重缺陷，既消耗内存又消耗CPU。

#### 注意监视表达式的大小

```html
<p>xxxxxxxxxxxxxxxxxx{{variable}}xxxxxx</P>
```

```html
<p>xxxxxxxxxxxxxxxxxxx<span ng-bind="variable"></span></p>
```

第二种方式比第一种方式性能好很多，第一种方式中<p>标签中的整段文字都会被当做表达式，这个长文本会在内存中被存储和拷贝。

### ng-repeat 指令

超过500行的数据对ng-repeat指令来说就不太合适了。















